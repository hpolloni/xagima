#include <cpu.h>
#include <stdint.h>
#include "gdt.h"
#include "idt.h"
#include "interrupt_frame.h"
#include <assert.h>
#include <io.h>

#define INTERRUPT_HANDLER_ENTRY(x) set_interrupt(x, static_cast<uint32_t>(reinterpret_cast<uintptr_t>(interrupt_handler_ ## x)));
#define INTERRUPT_HANDLER_WITH_ERROR_CODE(x) extern "C" __attribute__((interrupt)) \
void interrupt_handler_ ## x (cpu::interrupt_frame* frame, uint32_t) { \
  if (x >= 32) { \
    if (x >= 40) { \
      io::port::write<uint8_t>(0xA0, 0x20); \
    } \
    io::port::write<uint8_t>(0x20, 0x20); \
  } \
  cpu::interrupt_manager::instance().handle_interrupt(x, frame); \
}

#define INTERRUPT_HANDLER_NO_ERROR_CODE(x) extern "C" __attribute__((interrupt)) \
void interrupt_handler_ ## x (cpu::interrupt_frame* frame) { \
  if (x >= 32) { \
    if (x >= 40) { \
      io::port::write<uint8_t>(0xA0, 0x20); \
    } \
    io::port::write<uint8_t>(0x20, 0x20); \
  } \
  cpu::interrupt_manager::instance().handle_interrupt(x, frame); \
}

INTERRUPT_HANDLER_NO_ERROR_CODE(0)
INTERRUPT_HANDLER_NO_ERROR_CODE(1)
INTERRUPT_HANDLER_NO_ERROR_CODE(2)
INTERRUPT_HANDLER_NO_ERROR_CODE(3)
INTERRUPT_HANDLER_NO_ERROR_CODE(4)
INTERRUPT_HANDLER_NO_ERROR_CODE(5)
INTERRUPT_HANDLER_NO_ERROR_CODE(6)
INTERRUPT_HANDLER_NO_ERROR_CODE(7)
INTERRUPT_HANDLER_WITH_ERROR_CODE(8)
INTERRUPT_HANDLER_NO_ERROR_CODE(9)
INTERRUPT_HANDLER_WITH_ERROR_CODE(10)
INTERRUPT_HANDLER_WITH_ERROR_CODE(11)
INTERRUPT_HANDLER_WITH_ERROR_CODE(12)
INTERRUPT_HANDLER_WITH_ERROR_CODE(13)
INTERRUPT_HANDLER_WITH_ERROR_CODE(14)
INTERRUPT_HANDLER_NO_ERROR_CODE(15)
INTERRUPT_HANDLER_NO_ERROR_CODE(16)
INTERRUPT_HANDLER_WITH_ERROR_CODE(17)
INTERRUPT_HANDLER_NO_ERROR_CODE(18)
INTERRUPT_HANDLER_NO_ERROR_CODE(19)
INTERRUPT_HANDLER_NO_ERROR_CODE(20)
INTERRUPT_HANDLER_NO_ERROR_CODE(21)
INTERRUPT_HANDLER_NO_ERROR_CODE(22)
INTERRUPT_HANDLER_NO_ERROR_CODE(23)
INTERRUPT_HANDLER_NO_ERROR_CODE(24)
INTERRUPT_HANDLER_NO_ERROR_CODE(25)
INTERRUPT_HANDLER_NO_ERROR_CODE(26)
INTERRUPT_HANDLER_NO_ERROR_CODE(27)
INTERRUPT_HANDLER_NO_ERROR_CODE(28)
INTERRUPT_HANDLER_NO_ERROR_CODE(29)
INTERRUPT_HANDLER_WITH_ERROR_CODE(30)
INTERRUPT_HANDLER_NO_ERROR_CODE(31)
INTERRUPT_HANDLER_NO_ERROR_CODE(32)
INTERRUPT_HANDLER_NO_ERROR_CODE(33)
INTERRUPT_HANDLER_NO_ERROR_CODE(34)
INTERRUPT_HANDLER_NO_ERROR_CODE(35)
INTERRUPT_HANDLER_NO_ERROR_CODE(36)
INTERRUPT_HANDLER_NO_ERROR_CODE(37)
INTERRUPT_HANDLER_NO_ERROR_CODE(38)
INTERRUPT_HANDLER_NO_ERROR_CODE(39)
INTERRUPT_HANDLER_NO_ERROR_CODE(40)
INTERRUPT_HANDLER_NO_ERROR_CODE(41)
INTERRUPT_HANDLER_NO_ERROR_CODE(42)
INTERRUPT_HANDLER_NO_ERROR_CODE(43)
INTERRUPT_HANDLER_NO_ERROR_CODE(44)
INTERRUPT_HANDLER_NO_ERROR_CODE(45)
INTERRUPT_HANDLER_NO_ERROR_CODE(46)
INTERRUPT_HANDLER_NO_ERROR_CODE(47)

namespace cpu {
  global_descriptor_table gdt;
  interrupt_descriptor_table idt;

  idt_entry create_idt_entry(uint32_t base, uint16_t cs, uint8_t flags) {
    idt_entry entry = {};
    entry.fields.base_low = base & 0xFFFF;
    entry.fields.base_high = (base >> 16) & 0xFFFF;
    entry.fields.cs = cs;
    entry.fields.zero = 0;
    entry.fields.flags = flags;
    return entry;
  }

  void set_interrupt(uint8_t int_no, uint32_t interrupt_address) {
    idt.set(int_no, create_idt_entry(interrupt_address, 0x08, 0x8E));
  }

  void interrupts_init() {
    INTERRUPT_HANDLER_ENTRY(0)
    INTERRUPT_HANDLER_ENTRY(1)
    INTERRUPT_HANDLER_ENTRY(2)
    INTERRUPT_HANDLER_ENTRY(3)
    INTERRUPT_HANDLER_ENTRY(4)
    INTERRUPT_HANDLER_ENTRY(5)
    INTERRUPT_HANDLER_ENTRY(6)
    INTERRUPT_HANDLER_ENTRY(7)
    INTERRUPT_HANDLER_ENTRY(8)
    INTERRUPT_HANDLER_ENTRY(9)
    INTERRUPT_HANDLER_ENTRY(10)
    INTERRUPT_HANDLER_ENTRY(11)
    INTERRUPT_HANDLER_ENTRY(12)
    INTERRUPT_HANDLER_ENTRY(13)
    INTERRUPT_HANDLER_ENTRY(14)
    INTERRUPT_HANDLER_ENTRY(15)
    INTERRUPT_HANDLER_ENTRY(16)
    INTERRUPT_HANDLER_ENTRY(17)
    INTERRUPT_HANDLER_ENTRY(18)
    INTERRUPT_HANDLER_ENTRY(19)
    INTERRUPT_HANDLER_ENTRY(20)
    INTERRUPT_HANDLER_ENTRY(21)
    INTERRUPT_HANDLER_ENTRY(22)
    INTERRUPT_HANDLER_ENTRY(23)
    INTERRUPT_HANDLER_ENTRY(24)
    INTERRUPT_HANDLER_ENTRY(25)
    INTERRUPT_HANDLER_ENTRY(26)
    INTERRUPT_HANDLER_ENTRY(27)
    INTERRUPT_HANDLER_ENTRY(28)
    INTERRUPT_HANDLER_ENTRY(29)
    INTERRUPT_HANDLER_ENTRY(30)
    INTERRUPT_HANDLER_ENTRY(31)
    INTERRUPT_HANDLER_ENTRY(32)
    INTERRUPT_HANDLER_ENTRY(33)
    INTERRUPT_HANDLER_ENTRY(34)
    INTERRUPT_HANDLER_ENTRY(35)
    INTERRUPT_HANDLER_ENTRY(36)
    INTERRUPT_HANDLER_ENTRY(37)
    INTERRUPT_HANDLER_ENTRY(38)
    INTERRUPT_HANDLER_ENTRY(39)
    INTERRUPT_HANDLER_ENTRY(40)
    INTERRUPT_HANDLER_ENTRY(41)
    INTERRUPT_HANDLER_ENTRY(42)
    INTERRUPT_HANDLER_ENTRY(43)
    INTERRUPT_HANDLER_ENTRY(44)
    INTERRUPT_HANDLER_ENTRY(45)
    INTERRUPT_HANDLER_ENTRY(46)
    INTERRUPT_HANDLER_ENTRY(47)
  }

  void init() {
    interrupts_init();
    gdt.flush();
    idt.flush();

    io::port::write(0x20, (uint8_t)0x11);
    io::port::write(0xA0, (uint8_t)0x11);
    io::port::write(0x21, (uint8_t)0x20);
    io::port::write(0xA1, (uint8_t)0x28);
    io::port::write(0x21, (uint8_t)0x04);
    io::port::write(0xA1, (uint8_t)0x02);
    io::port::write(0x21, (uint8_t)0x01);
    io::port::write(0xA1, (uint8_t)0x01);
    io::port::write(0x21, (uint8_t)0x00);
    io::port::write(0xA1, (uint8_t)0x00);
 
    asm("sti");
  }
}
